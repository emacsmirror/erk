#+TITLE: Elisp Repo Kit

#+PROPERTY: LOGGING nil

# NOTE: To avoid having this in the info manual, we use HTML rather than Org
# syntax; it still appears with the GitHub renderer.
#+HTML: <a href="https://melpa.org/#/elisp-repo-kit"><img src="https://melpa.org/packages/elisp-repo-kit-badge.svg" alt="melpa package"></a> <a href="https://stable.melpa.org/#/elisp-repo-kit"><img src="https://stable.melpa.org/packages/elisp-repo-kit-badge.svg" alt="melpa stable package"></a>
#+HTML: <a href="https://github.com/positron-solutions/elisp-repo-kit/actions/?workflow=CI"><img src="https://github.com/positron-solutions/elisp-repo-kit/actions/workflows/ci.yml/badge.svg" alt="CI workflow status"></a>
#+HTML: <a href="https://github.com/positron-solutions/elisp-repo-kit/actions/?workflow=Developer+Certificate+of+Origin"><img src="https://github.com/positron-solutions/elisp-repo-kit/actions/workflows/dco.yml/badge.svg" alt="DCO Check"></a>

This repository is a kit to start a new elisp package repository.  The package
contained has commands to streamline elisp development.

* Quickly set up an Emacs Lisp repository on Github with:

- An [[https://www.youtube.com/watch?v=RQK_DaaX34Q&list=PLEoMzSkcN8oPQtn7FQEF3D7sroZbXuPZ7][elisp]] package
- Bytecode compiling, linting, and test running
- Commands to handle common elisp development gotchas
- CI with [[https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs][Github Actions]], configured for Darwin (MacOS) and Linux
- [[https://nixos.org/#examples][Nix]] environment for obtaining dependencies or reproducibly developing CI
  locally
- Licensing, [[https://developercertificate.org/][DCO]], and DCO sign-off checks for PR's
- [[https://github.com/melpa/melpa][MELPA]] publishing compatible

*To get started:*

Install the package and run =erk-new=, provide a directory, and
answer all the questions.

** Install elisp-repo-kit

  #+begin_src elisp

    (use-package elisp-repo-kit)

    ;; straight-use-package-by-default t and you want a git version
    (use-package elisp-repo-kit
      :straight
      (elisp-repo-kit :type git :host github :repo "positron-solutions/elisp-repo-kit"))

    ;; using elpaca (recommended to add a hash for reproducibility)
    (elpaca-use-package
     (example :host github
              :repo "positron-solutions/elisp-repo-kit"))

    ;; if straight-use-package-by-default is nil
    (straight-use-package '(elisp-repo-kit :type git :host github
                                           :repo "positron-solutions/elisp-repo-kit"))

    ;; or use melpa, manual load-path & require, you brave yak shaver

  #+end_src

=erk-new= will ask for:

  - Root directory you want to clone to
  - Package name
  - Package prefix
  - Author name
  - Github user or organization
  - Email address

 The =erk-new= calls =erk-rename-relicense= to rename all of the files, string
 replace names, and re-license to GPL3.  Now just follow the steps in [[#finish-setting-up-your-new-github-repo][finish
 setting up]] Have fun!

*** Manual cloning

  The standalone command, =erk-clone= will clone without renaming.

  This repo is also a [[https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template][template repository]], so you can fork without forking
  (Bruce Lee).

  If you create via template or clone manually, it's presumed you know what
  you're doing at that point.  Call =erk-rename= on its own to rename
  in these cases.

  There are some customize options that cause the renaming to be transitively
  consistent.

* Contents                                                         :noexport:
:PROPERTIES:
:TOC:      :include siblings
:END:
:CONTENTS:
- [[#local-development-instructions][Local development instructions]]
  - [[#run-tests][Run tests]]
  - [[#lint-and-byte-compile-code][Lint and byte-compile code]]
  - [[#loading-and-re-loading-your-package][Loading and re-loading your package]]
- [[#finish-setting-up-your-new-github-repo][Finish setting up your new Github repo]]
  - [[#optional-steps][Optional Steps]]
- [[#publishing-to-melpa][Publishing to MELPA]]
  - [[#creating-the-recipe][Creating the recipe]]
  - [[#testing-package-build][Testing package build]]
  - [[#testing-stable-package-build][Testing stable package build]]
  - [[#melpa-lints][MELPA Lints]]
- [[#overview-of-file-contents-and-structure][Overview of file contents and structure]]
- [[#maintaining-your-versions][Maintaining your versions]]
- [[#licensing-developer-certificate-of-origin][Licensing, Developer Certificate of Origin]]
  - [[#license][License]]
  - [[#developer-certificate-of-origin-dco][Developer Certificate of Origin (DCO)]]
    - [[#sign-off][Sign-off]]
    - [[#gpg-signature][GPG signature]]
    - [[#user-setup-for-submitting-changes][User setup for submitting changes]]
      - [[#automatically-add-sign-off][Automatically add sign-off]]
      - [[#automatic-gpg-signing-with-per-project-keys][Automatic GPG signing with per-project keys]]
      - [[#manually-signing--adding-sign-off][Manually signing & adding sign-off]]
- [[#package-scope-and-relation-to-other-work][Package scope and relation to other work]]
  - [[#dependency-management][Dependency Management]]
  - [[#discovering-and-running-tests--lints][Discovering and Running Tests & Lints]]
  - [[#comparisons][Comparisons]]
- [[#contributing][Contributing]]
- [[#shout-outs][Shout-outs]]
- [[#footnote-on-fsf-and-emacs-core-licensing][Footnote on FSF and Emacs Core Licensing]]
:END:

* Use to develop your package

  Elisp repo kit contains some convenience functions to reload your package and
  to discover and run ert tests.  These shortcuts just make common cases faster.

** Run tests

   Run =erk-ert-project= within your project.  The tests in =/test=
   will be discovered, rebuilt & reloaded if necessary, and run.  There are a
   few other commands to augment the [[https://www.gnu.org/software/emacs/manual/html_node/ert/][ert]] package.

*** Running tests CI style

   If you cannot reproduce a failure (or success) on CI, then you may want to
   switch to using nix to get a reprodicible toolchain so you can further
   develop with frozen versions from the nix [[https://nixos.wiki/wiki/Flakes][flake's]] flake.lock.

   #+begin_src bash

     nix develop # loads the devShells.default from flake.nix
     direnv allow # same as above with file watching

     emacs --quick --load ./test/run-shim.el -- test # graphical
     emacs --script ./test/run-test.el -- test # terminal

   #+end_src

   You can /totally/ run the tests locally on whatever version of Emacs you
   have.  *You do not need Nix to run tests.* CI will use Nix.

** Lint and byte-compile code

   Use [[https://github.com/gonewest818/elisp-lint][elisp-lint]] to detect issues with byte compiling, package format, code
   structure and others.

   The configuration is found inside [[./test/run-shim.el][test/run-shim.el]].  The CI run is invoked
   inside of [[.github/workflows/ci.yml][ci.yml]] using Emacs in script mode.  Most of the configuration is in
   the run shim.

   The tests are also linted, to a less restrictive standard, also found in
   [[./test/run-shim.el][run-shim.el]]

   You can run the lints manually almost the same as running tests.
   #+begin_src bash

     nix develop
     # nix develop .#emacs28
     # nix develop .#emacsGit
     emacs --script test/run-shim.el -- lint
     emacs --script test/run-shim.el -- lint-tests

   #+end_src

** Loading and re-loading your package

   Run =erk-reload-package= in one of your project files.  All features
   in the /lisp directory will be re-compiled and loaded appropriately.

   *Note*, during reloading, unloading the current module is forced.  If other
   packages you use depend on the project feature, results may be unpredicatable.
   This is one reason batch style testing can be preferred.

*** Manual Loading & Reloading

    To manually unload, run built-in command ~unload-feature~ and select your
    package name. If you do not unload, reloading has no effect and you will see
    stale behavior.

    Next, add the package to your load-path and then require it or, more
    directly, call =emacs-lisp-byte-compile-and-load= or
    =emacs-lisp-native-compile-and-load=.

    Especially in bootstrap situations such as working on this package itself,
    you cannot unload the package in the middle of a command.  Some commands
    have a =no-reload= variant just for this circumstance.

    When using locally installed packages such as with straight,
    =straight-rebuild-pacakge= will rebuild but *not* reload.

    Here's what such a local installation looks like:

    #+begin_src elisp :eval never

      (straight-use-package
       '(elisp-repo-kit :local-repo "~/my-packages/positron/elisp-repo-kit"))

    #+end_src

    Because the load path is configured above, you can call =(unload-feature
    'elisp-repo-kit)= and then =(require 'elisp-repo-kit)= to pick up changes.

* Finish setting up your new Github repo

  You can copy this checklist to your org agenda files:

  - [X] Create a repository (from [[#Install elisp-repo-kit][install]] instructions)
  - [ ] Create an empty Github repository and check the git remote configuration
  - [ ] Set up your git commit signing (and verification so that it's obvious)
    *and* [[#sign-off][sign-off]] so that it will be [[#Footnote-on-FSF-and-Emacs-Core-Licensing][straightforward]] for for FSF to pull in your
    changes if they later change to DCO instead of copyright assignment.
  - [ ] Sign up for [[https://app.cachix.org/][cachix]] and, create a binary cache
    with API tokens and public read access
  - [ ] Add secrets necessary for your Github actions =CACHIX_AUTH_TOKEN= and
    =CACHIX_CACHE_NAME=
  - [ ] Enable actions and add the following actions to your allowed actions
    list:

    #+begin_src

    actions/checkout@v3.2.0,
    cachix/cachix-action@v12,
    cachix/install-nix-action@v18,
    actions/setup-python@v4,

    #+end_src

    *Note*, Python is used to run a DCO check script, nothing more.

  - [ ] Get your package working, pushed, actions run, and CI badges all green
  - [ ] [[#Publishing-to-melpa][Publish]] to MELPA
  - [ ] Make a post on the [[https://old.reddit.com/r/emacs/][subreddit]] about your new package

** Optional Steps

 - [ ] Install =org-make-toc= for the automatic TOC generation in this org
   document to work.
 - [ ] Branch protect and enable check requirements for your default branch
   (usually master).  Merge commits, verified only, and no force push are
   recommended settings.
 - [ ] Enable requiring contributors to sign-off on web-based commits
 - [ ] For security of your Cachix secrets and any other secrets you may someday
   add, require Actions approval for all outside contributors and leave
   repository permissions at read-only

 Cachix is somewhat optional.  It's free for open-source projects.  It's about as
 easy to sign up and generate the token as to remove the step from the Github
 actions, so you won't save much time by avoiding it.

* Publishing to MELPA

  If you have green CI, you have already passed many requirements of publishing a
  MELPA package.  *You still need to build your package and verify your recipe.*
  You are going to clone melpa in order to make your PR.  You can use the clone to
  verify the recipe.

** Creating the recipe

   Fork MELPA personally (not for organization) and clone it to wherever you keep
   your upstreams.  It's a good idea to separate upstreams from projects you
   actively maintain so you can see and delete upstreams when not in use.

   #+begin_src shell

     mkdir -p upstream
     cd upstream
     git clone git@github.com:$GITHUB_USER/melpa.git  # replace $GITHUB_USER

   #+end_src

   Install package-build

   #+begin_src elisp
     (use-package package-build)
   #+end_src

   =package-build-create-recipe= will give you something like:

   #+begin_src elisp
   (elisp-repo-kit :fetcher github :repo "positron-solutions/elisp-repo-kit")
   #+end_src

   The following template can be filled in and pull-requested to MELPA to publish.
   You don't need to touch ~:files~.  The ~commit~ and ~branch~ are optional
   depending on how you version / develop / tag your releases.

   Copy the recipe into =recipes/elisp-repo-kit= inside your MELPA clone.

** Testing package build

   Inside the MELPA clone root:

   #+begin_src shell

     # Builds the package
     make recipes/elisp-repo-kit
     # Test sandbox installation (will affect ~/.emacs.d/elpa  So much for sandbox ¯\_(ツ)_/¯
     EMACS_COMMAND=$(which emacs) make sandbox INSTALL=elisp-repo-kit

   #+end_src

** Testing stable package build

   You need a tag on your default (usually master) branch of your repo,
   =positron-solutions/elisp-repo-kit=. Use =git tag -S v0.1.0= and =git push
   origin v0.1.0=.  You can also just create a release in the Github interface.

   #+begin_src shell

     # Test stable builds against your tags
     STABLE=t make recipes/elisp-repo-kit

   #+end_src

** MELPA Lints

   Lastly, install [[https://github.com/riscy/melpazoid][melpazoid]] and call =melpazoid= on your main feature.  It does
   some additional lints.  You may need to install =package-lint= if you don't have
   it.  It's not declared in melpazoid's requirements.  Getting the package in Nix
   is not easy yet since melpazoid is not yet on Melpa.

   #+begin_src elisp

     (straight-use-package
      '(melpazoid :type git :host github :repo "riscy/melpazoid" :files ("melpazoid/melpazoid.el")))

   #+end_src

   If everything works, you are ready to make a pull request to MELPA.  Push your
   changes and check all the boxes in the PR template except the one that requires
   you to read the instructions.

* Overview of file contents and structure

  /After cloning and renaming,/ you will have a file tree like this:

  #+begin_src shell

    ├── .gitignore                        # ignores for byte compiles, autoloads etc
    ├── flake.nix                         # dependencies for this project
    ├── flake.lock                        # version controlled lock of flake.nix input versions
    ├── .envrc                            # direnv integration with `nix develop`
    │
    ├── README.org                        # this file
    ├── COPYING                           # a GPL3 license
    ├── DCO                               # Developer Certificate of Origin
    │
    ├── .github
    │   ├── pull_request_template.md      # reminders for PR contributors
    │   └── workflows
    │       ├── ci.yml                    # workflow for lints and tests
    │       └── dco.yml                   # workflow to check DCO sign-offs
    │
    ├── lisp
    │   └── elisp-repo-kit.el             # the package
    │
    └── test
        ├── elisp-repo-kit-test.el        # ERT unit tests
        └── run-shim.el                   # elisp script with test & lint routines

  #+end_src

* Maintaining nixpkgs versions

  Nixpkgs has a new release about every six months.  You can check their [[https://github.com/NixOS/nixpkgs/branches][branches]]
  and [[https://github.com/NixOS/nixpkgs/tags][tags]] to see what's current.  To get updated dependencies from MELPA, it's
  necessary to update the emacs-overlay with =nix flake lock --update-input
  emacs-overlay=.  You can also specify revs and branches if you need to roll
  back. There is a make shortcut: =make flake-update= MacOS tends to get a little
  less test emphasis, and so =nixpkgs-darwin-<version>= branches exist and are
  required to pass more Darwin tests before merging.  This is more stable if you
  are on MacOS. =nixpkgs-unstable= or =master= are your other less common options.

* Licensing, Developer Certificate of Origin

  This project is distributed with a Developer Certificate of Origin.  By adding
  a sign-off notice and GPG signature to each commit, you will provide means to
  authenticate your sign-off later strengthening your attestations stated in the
  DCO, upholding the overall integrity of the license coverage over the project.

  If you fail to implement this scheme, Emacs core will have significant reasons
  not to directly merge changes that accumulate in your package because there
  will not be a clear attestation of authority to submit changes under the terms
  of your project's license.

** License

   This template project is distributed with the MIT license. Running the rename
   command will automatically switch to the GPL license.  *The MIT license
   allows re-licensing, and so this change is compatible.* If you accept
   non-trivial changes to your project, it will be very hard to change to the
   GPL3 later, so consider this choice.

** Developer Certificate of Origin (DCO)

   A [[./DCO][copy of the DCO]] is distributed with this project.  Read its text to
   understand the significance of configuring for sign-off.

*** Sign-off

    A sign-off means adding a "trailer" to your commit that looks like the
    following:

    #+begin_src

    Signed-off-by: Random J Developer <random@developer.example.org>

    #+end_src

*** GPG signature

    A GPG signed commit shows that the owner of the private key submitted the
    changes.  Wherever signatures are recorded in chains, they can demonstrate
    participation in changes elsewhere and awareness of what the submitter is
    participating in.  Corroborating user's signature accross a history of works
    strengthens that user's attestation provided by DCO sign-off.

*** User setup for submitting changes

    Follow these instructions before you get ready to submit a pull-request.

    Refer to the [[https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits][Github signing commits]] instructions to set up your git client
    to add GPG signatures.  File issues if you run into Emacs-specific problems.

    Because signing is intended to be a conscious process, please remember to
    read and understand the [[./DCO][Developer Certificate of Origin]] before confinguring
    your client to automatically sign-off on commits.

**** Automatically add sign-off

     In magit, set the =-s= switch.  Use =C-x C-s= (=transient-save=) to
     preserve this switch on future uses.  (Note, this is not per-project).You
     can also set the signature flag this way.

**** Automatic GPG signing with per-project keys

     In order to specify which projects you intend to sign with which keys, you
     will want to configure your git client using path-specific configurations.

     Configuing git for this can be done with the following directory structure:

     #+begin_src

    /home/rjdeveloper/
    ├── .gitconfig
    └── .gitconfig.d
        ├── sco-linux-projects.conf
        ├── other-projects.conf
        └── gpg-signing-projects.conf

     #+end_src

     In your root config, ~.gitconfig~, add an =includeIf= directive that will
     load the configuration you use for projects you intend to GPG sign commits
     for.

     #+begin_src

    [includeIf "gitdir:/home/rjdeveloper/**/gpg-signing/**/.git"]
      path = "~/.gitconfig.d/gpg-signing-projects.conf"

     #+end_src

     In the ~gpg-signing-projects.conf~ add your GPG signing configuration from
     earlier.  =sign= adds the GPG signature automatically.  File an issue if you
     need help with multiple GPG homes or other configurations.

     #+begin_src

    [user]
      name = "Random J Developer"
      email = "random@developer.example.org"
      signingkey = "5FF0EBDC623B3AD4"

    [commit]
      sign = true
      gpgSign = true

     #+end_src

**** Manually signing & adding sign-off

     If you don't like these configurations and want to individually indicate you
     have read and intend to apply the DCO to your changes, these commands are
     equivalent:

     #+begin_src bash
       git commit -s -S --message "I don't like using .gitconfig"

       # To clean up a commit
       git commit --amend -s -S --no-message

       # Combine with rebase to sign / sign-off multiple existing commits
       git rebase -i
     #+end_src

* Package scope and relation to other work

  There are two functional goals of this repository:

  - Automate the annoying work necessary to set up a new repository
  - Streamline common elisp development workflows

  Commands within this package will focus on cleaner integration of the tests and
  lints with Emacs.  There has been a lot of work in this area, but much of it is
  tangled with dependency management and sandbox creation.  Much of the work is
  done in languages other than elisp and focused on non-interactive workflows
  with no interactive integration on top.

  Providing close to out-of-box CI is a big focus.  By making it easier to
  qualify changes from other users, it becomes less burdonsome to maintain
  software, and by extension, less burdensom to publish and create software. The
  effect is to drive creation of elisp in a way that can accelerate the flow of
  elisp into Emacs itself.

** Dependency Management

   This repository uses pure dependency management and then levarages it to
   provide dependencies for development and CI environments.  The resulting user
   experience is built around CI for reproducibility and interactive testing for
   development speed.

   Because most elisp dependencies can be obtained without extensive system
   dependency management, many tools for testing Emacs packages provide
   dependency management and loading those dependencies into a fresh Emacs
   instance.  This aligns well with ad-hoc sandboxed local testing.  This was
   fine in the old days of impure dependency management and dirty environments.

   The [[https://github.com/nix-community/emacs-overlay][Emacs Nix Overlay]] and Emacs support within nixpkgs make it possible to
   stating and obtaining elisp dependencies in a completely pure way.  Non-elisp
   dependencies are trivially provided form nixpkgs.  Nix is extremely reliable
   at dependency management, and it is no surprise that much complexity is
   normalized away by just the basic behavior model of Nix.  In addition, *if
   your project needs or includes additional binary dependencies or modules*,
   Nix is an excellent way to provide them to CI and users.

** Discovering and Running Tests & Lints

   During development, the commands provided under the =erk-= prefix make it
   more convenient to reload your package and test features.  You can run the
   ert tests for a project while working on multiple packages.

   During CI, this repository uses an elisp shim for discovering and running
   tests.  The commands within the package for convenience during development
   are not depeneded upon during CI.

   The CI actions obtain an environment with dependencies using Nix, so this can
   also be done locally using Nix, meaning re-creating environments is available
   to the user without leaning on CI.

** Comparisons

   There are many comparisons available to understand the roles of similar tools
   and how they relate to each other.

   - [[https://github.com/alphapapa/makem.sh#comparisons][makem.sh]]
   - [[https://github.com/doublep/eldev#see-also][Eldev]]
   - [[https://github.com/emacs-twist/nomake][nomake]] Is another project with Nix work

   [[https://github.com/purcell/nix-emacs-ci][nix-emacs-ci]] capture the work needed to provide a running Emacs to CI.  Tools
   like [[https://github.com/doublep/eldev#continuous-integration][eldev]] and [[https://github.com/alphapapa/makem.sh/blob/master/test.yml][makem.sh]] have support for providing dependencies to that Emacs.
   The Nix flake [[./flake.nix][in this project]] describes both of these tasks.  Makem and Eldev
   etc document Gihub workflows, but *the workflows in this repository are meant to
   be used out-of-the-box after cloning*, although to be fair, there's more
   decisions than actual work.

   Nix-emacs-ci provides a lot of backwards-compatibility versions of Emacs.  The
   nix-overlay is more forward looking, providing =emacsGit= and sometimes other
   upstream branches when a big feature like native compilation is in the pipeline.
   Nix-emacs-ci is also still using legacy Nix, without flakes.  Flakes are just
   nicer and the way Nix is going.

* Contributing

  First decide if you want to work on this repository or fork it to something
  entirely different.

  Non-exhaustive list of changes that are very welcome:

  - More interactive integrations with high-value elisp development workflows
  - Running additional or better kinds of tests & lints
  - Fix bugs
  - Expose trivial options where a structural choice has limited them
    unnecessarily
  - Behave the same, but with a less complicated code
  - Guix or other pure dependency management support

  Changes will likely be rejected if it is aimed at:

  - Non-elisp interfaces meant for invocation outside of Emacs or with scripting
    implemented in a language besides elisp.
  - Managing dependencies outside of Nix (or other pure dependency management)
    expressions
  - CI infrastructure support for non-Actions infrastructure (which cannot be
    tested in this repo)
  - Backwards compatibility for Emacs two versions behind next release.  Master,
    current stable release, and release - 1 are the only versions being supported
  - pre-flake Nix support
  - Guix support that interferes with Nix support

* Shout-outs

  - [[https://github.com/alphapapa][alphapapa]] for being super prolific at everything, including package writing,
    documentation, and activity on various social platforms
  - [[https://github.com/adisbladis][adisbladis]] for the Nix overlay that makes the CI and local development so nice
  - [[https://github.com/NobbZ][NobbZ]] for being all over the Nix & Emacs interwebs
  - [[https://www.fsf.org/][FSF]] and all contributors to Emacs & packages for the Yak shaving club

* Footnote on FSF and Emacs Core Licensing

  Free Software Foundation (FSF) frequently requires copyright assignment on all
  code that goes into Emacs core. Many GNU projects have since switched to using
  a Developer Certificate of Origin.  DCO sign-off is a practice accepted by
  git, GCC, and the [[https://wiki.linuxfoundation.org/dco][Linux Kernel]].

  Doing DCO sign-off is not the same as copyright assignment, and serves a
  slightly different purpose.  DCO sign-off is an attestation from the submitter
  stating that they have sufficient direct or transitive authority make their
  submission under the terms of the license of the recieving project.  Copyright
  assignment serves a more offensive role in the case of GPL non-compliance,
  giving FSF alone legal standing.  If you don't care about FSF being able to
  sue people, the DCO should suffice.

  Using the DCO *may* make it easier for code in your project to be included in
  Emacs core later.  *It is the intent of this choice to steer FSF towards
  DCO-like solutions in order to accelerate code flow into Emacs.* Regardless of
  FSF's ongoing position on use of DCO's, by requiring DCO sign-off and GPG
  signature, you can be assured that changes submitted to a code base you
  control are strongly attested to be covered by the license you chose.

# Local Variables:
# before-save-hook: (when (require 'org-make-toc nil t) (org-make-toc))
# org-export-with-properties: ()
# org-export-with-title: t
# End:
